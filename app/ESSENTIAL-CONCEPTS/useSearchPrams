Below is a clear, complete, and practical explanation of useSearchParams in Next.js, including the theory and a real-world example program.

1. What is useSearchParams in Next.js?

useSearchParams is a React hook provided by Next.js App Router that allows you to read values from the URL’s query string on the client side.

Example URL:

/products?category=gutkha&page=2


Here,

category=gutkha

page=2

These are search parameters (also called query parameters).

In Next.js App Router, you can access them using:

const searchParams = useSearchParams();
const category = searchParams.get("category");

2. Why do we use useSearchParams?

You use this hook when the UI changes based on what is written in the URL, such as:

1. Filtering
/products?category=surti


The UI should display Surti items.

2. Search pages
/search?query=mobile


The UI shows results for "mobile".

3. Pagination
/products?page=3

4. Sorting
/products?sort=price_asc

5. Maintaining browser state

When the user reloads

When the user shares the link

When user presses back/forward

The state remains preserved, because URL values remain.

3. How useSearchParams Works (Concept)

useSearchParams returns an object similar to URLSearchParams.

So you can do:

searchParams.get("category")
searchParams.has("page")
searchParams.get("sort")


It is readonly — you cannot change the URL directly using it.

To update search params, you use:

useRouter().push()

OR usePathname() with updated params

Example:

router.push(`/products?category=surti`)

4. Simple Example Program (Full Working Code)
Goal:

Read category from URL

Fetch data based on that category

Buttons update the URL

app/products/page.js
"use client";

import { useSearchParams, useRouter } from "next/navigation";
import useSWR from "swr";

const fetcher = (...args) => fetch(...args).then(res => res.json());

export default function ProductsPage() {
    const searchParams = useSearchParams();
    const router = useRouter();

    // Read ?category= from URL
    const category = searchParams.get("category") || "all";

    // Fetch products based on category
    const { data, isLoading, error } = useSWR(
        `/api/products?category=${category}`,
        fetcher
    );

    // Update category in URL
    const handleCategory = (newCategory) => {
        router.push(`/products?category=${newCategory}`);
    };

    return (
        <div>

            <h1>Products</h1>

            <div className="flex gap-3">

                <button 
                    onClick={() => handleCategory("gutkha")}
                    className={category === "gutkha" ? "bg-yellow-300" : "bg-gray-200"}
                >
                    Gutkha
                </button>

                <button 
                    onClick={() => handleCategory("surti")}
                    className={category === "surti" ? "bg-yellow-300" : "bg-gray-200"}
                >
                    Surti
                </button>

            </div>

            <hr className="my-5" />

            {isLoading && <p>Loading...</p>}
            {error && <p>Error loading data</p>}

            {data && (
                <ul>
                    {data.products.map((item) => (
                        <li key={item.id}>{item.name}</li>
                    ))}
                </ul>
            )}

        </div>
    );
}

5. What This Example Teaches You
1. URL Changes → UI Changes

When user clicks "Surti":

/products?category=surti

2. The page does NOT reload

React updates content dynamically.

3. Search params make your UI shareable

If someone shares:

/products?category=gutkha


Anyone opening it will see Gutkha products.

4. Reusable pattern for:

filters

sorting

pagination

tabs

search

6. When to use useSearchParams vs useState
Scenario	Use
State should appear in URL	useSearchParams
User should be able to reload or share the page	useSearchParams
State is internal (forms, modals, toggles)	useState
Complex filtering + SEO-like URLs	useSearchParams